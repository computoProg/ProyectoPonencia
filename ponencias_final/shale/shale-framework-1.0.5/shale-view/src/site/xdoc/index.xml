<?xml version="1.0"?>
<document>
<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to you under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
  <properties>
    <title>Shale View Controller</title>
  </properties>

  <body>
    
    <section name="Shale View Controller">
    <a name="view"/>

      <a name="view-introduction"/>
      <subsection name="Introduction">

        <p>Shale supports a mechanism that provides a 1:1 relationship between
        a view tier presentation technology, which is responsible for creating
        an HTTP response (such as a JSP page), and a corresponding JavaBean class
        containing event handling logic, (optionally) values used in the dynamic
        rendering of the response, and (optionally) bindings to the individual
        user interface components included in the response page.  Such a JavaBean
        class is known (in JavaServer Faces terminology) as a <em>backing bean</em>.
        In most circumstances, such a bean will be registered as a managed bean
        (configured for creation in request scope).</p>

        <p>JavaServer Faces does not require that a backing bean implement any
        particular interface, or extend any particular base class.  Therefore,
        Shale does not impose any such restriction either.  Instead, it promises
        that <em>if</em> an application's backing bean implements the
        <code>ViewController</code> interface, then certain extra services will
        be provided "for free."</p>

      </subsection>

      <a name="view-services"/>
      <subsection name="Provided Services">

        <p>Each backing bean that implements <code>ViewController</code> will
        support a boolean property <code>postback</code>, which will be set to
        <code>true</code> if this view is the one that is processing a form
        submit previously rendered by the same page, or <code>false</code> if
        this view was newly navigated to.  The property will be set before any
        of the lifecycle methods described below are called, so that application
        logic may perform conditional tasks based on this state.</p>
        
        <p>As part of the standard JavaServer Faces managed beans processing, any
        <code>&lt;managed-property&gt;</code> elements in the configuration
        file, that are nested inside the <code>&lt;managed-bean&gt;</code>
        element for this backing bean, will also be processed when a new bean
        instance is created.  You can use either literal values or value binding
        expressions to customize properties on your backing bean class.  Fans
        of <em>Dependency Injection</em> will see that the managed beans facility
        provides support for such a framework, using Setter Injection as the
        mechanism for injecting dependencies.</p>

        <p>In addition, the following lifecycle events are called, by the
        framework, at certain points in the JavaServer Faces request processing
        lifecycle:</p>

        <ul>
        <li><strong>init()</strong> - Called immediately after the view that
            this backing bean is associated with is created.  (Technically, it
            happens when <code>ViewManager.createView()</code> is called.)
            For a postback, this happens during the <em>Restore View</em>
            phase of the request processing lifecycle, once it has been
            determined which view should be restored.  If your application
            navigates from one page to another, the <code>init()</code> method
            of the second page will be called as part of the
            <code>NavigationHandler.handleNavigation()</code> processing.
            <blockquote>
              Use this method to acquire resources that you will need, no
              matter whether this is a postback request, a rendering request,
              or both.
            </blockquote></li>
        <li><strong>preprocess()</strong> - Called after the <em>Restore View</em>
            phase has been completed, but before <em>Apply Request Values</em>
            phase starts, <strong>only</strong> for the view that will be
            processing the postback.
            <blockquote>
              Use this method to acquire resources (such as database connections)
              that you will need to process the postback.
            </blockquote></li>
        <li><strong>prerender()</strong> - Called immediately before the
            <em>Render Response</em> phase that actually causes the view to
            be rendered.  This method will <strong>only</strong> be called for
            the view that is actually rendered (the current view if you are
            redisplaying, or the new view if you perform navigation).
            <blockquote>
              Use this method to acquire resources (such as database connections,
              or performing queries) that you will need if this view is the one
              to be rendered.  NOTE - when portlet support is integrated, all of
              the portlets on the current page will receive this event.
            </blockquote></li>
        <li><strong>destroy()</strong> - If <code>init()</code> was ever called
            for a <code>ViewController</code>, then it is guaranteed that
            <code>destroy()</code> will be called as well.
            <blockquote>
              Use this method to release any resources acquired during an earlier
              event handler.
            </blockquote></li>
        </ul>

        <p>It can be difficult initially to visualize the order that events will
           occur, based solely on the descriptions above.  Let's look at some
           common scenarios and see what happens when:</p>
        
        <ul>
        <li><em>Initial navigation to welcome page, or a page directly accessed
            via a URL</em>:
            <ul>
            <li>Backing bean is instantiated during <em>Restore View</em> phase,
                which notices that there is no previous state to restore.</li>
            <li>The <code>setPostback(false)</code> and <code>init()</code> methods
                on your backing bean are called.</li>
            <li>Because there is no previous state to restore, there will be no
                form submit processing.</li>
            <li>The <code>prerender()</code> method is called.</li>
            <li>Standard <em>Render Response</em> phase processing occurs,
                which causes the view to be rendered.</li>
            <li>The <code>destroy()</code> method is called.</li>
            </ul></li>
        <li><em>Postback processed by a page that then redisplays itself (by
            returning <code>null</code> from the action handler.)</em>:
            <ul>
            <li>Backing bean is instantiated during <em>Restore View</em> phase,
                which notices that there is previous state to restore.</li>
            <li>The <code>setPostback(true)</code> and <code>init()</code> methods
                on your backing bean are called.</li>
            <li>Standard <em>Apply Request Values</em> through <em>Invoke
                Application</em> phase processing occurs, which includes calling
                your action and value change event handlers.</li>
            <li>The <code>prerender()</code> method is called.</li>
            <li>Standard <em>Render Response</em> phase processing occurs,
                which causes the view to be rendered.</li>
            <li>The <code>destroy()</code> method is called.</li>
            </ul></li>
        <li><em>Postback processed by page A, which then navigates to page B</em>:
            <ul>
            <li>Backing bean for page A is instantiated during <em>Restore View</em>
                phase, which notices that there is previous state to restore.</li>
            <li>The <code>setPostback(true)</code> and <code>init()</code> methods
                on your backing bean for page A are called.</li>
            <li>Standard <em>Apply Request Values</em> through <em>Invoke
                Application</em> phase processing occurs for page A, which
                includes calling your action and value change event handlers.</li>
            <li>As part of the navigation process, the backing bean for
                page B is created.</li>
            <li>The <code>prerender()</code> method for page B is called.</li>
            <li>Standard <em>Render Response</em> phase processing occurs,
                which causes the view to be rendered.</li>
            <li>The <code>destroy()</code> method is called for both page B
                and page A (since two backing beans were instantiated).</li>
            </ul></li>
        </ul>

      </subsection>

      <a name="view-using"/>
      <subsection name="Using View Controller">

        <p>For each JavaServer Faces <em>view</em> that you wish to associate
        with a <code>ViewController</code> backing bean, you must:</p>

        <ul>
          <li>Implement the
              <a href="apidocs/org/apache/shale/view/ViewController.html" target="_blank">
              <code>ViewController</code></a>
              interface.  The 
              most convenient way to do this is likely to be extending the 
              convenience base class (<code>org.apache.shale.view.AbstractViewController</code>).</li>
          <li>As required by the 
              <a href="http://java.sun.com/products/javabeans/" target="_blank">JavaBeans</a>
              specification, provide a no-args public constructor.</li>
          <li>Declare your backing bean as a <code>&lt;managed-bean&gt;</code>, 
              using a <code>&lt;managed-bean-name&gt;</code> value that can be 
              mapped from the view identifier.  (See 
              <a href="apidocs/org/apache/shale/view/impl/DefaultViewControllerMapper.html" target="_blank">
              <code>DefaultViewControllerMapper</code></a> for the details of
              the default mapping.)
              In nearly all circumstances, you will want the bean to be placed 
              in request scope.</li>
          <li>(Optional) Provide public JavaBean properties that may be set
              to customize the functionality provided by this bean.  Typically,
              such properties will be configured based on the managed beans
              configuration defined in the JavaServer Faces configuration
              resources for your application.</li>
          <li>Ensure that the functionality of your backing bean is
              <strong>not</strong> dependent upon the order in which property
              setters are called, since managed beans are configured via
              the "setter injection" pattern.</li>
          <li>Create event handlers for the lifecycle events of interest,
              plus standard JavaServer Faces event handlers for things like
              actions and value changes.</li>
          <li>(Optional but recommended) Write a corresponding JUnit test
              case using the Shale <a href="../shale-test/index.html">Test Framework</a>.
              Because nearly all of your property and event handling methods
              have no JavaServer Faces API dependencies for their parameter
              signatures, it is generally quite easy to write such tests.</li>
        </ul>

      </subsection>


    </section>

  </body>

</document>
